import Crypto from './crypto';
const crypto = require('crypto');

// The validator should sit on the smart device.
// The signer needs to create trust for the backend. This is done via a blinded
// secret generated by the smart device. The device will be registered via the
// public key onto the blockchain.
export default class Device {
  // the amount should be inferred somehow from the events on device
  constructor() {
    // generate private and public keys
    const { privateKey, publicKey } = crypto.generateKeyPairSync('ec', {
      namedCurve: 'sect239k1',
      publicKeyEncoding:  { type: 'spki', format: 'pem' },
      privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
    });

    this.privateKey = privateKey;
    this.publicKey = publicKey;

    this.amount   = 0;
    this.counter  = 0;
  }

  // the message that arrives to the validator should be signed
  sign(clientPk) {

    // to sign the message, together with the nonce
    const message = clientPk + '|' + this.exportAmount() + '|' + this.counter;

    // get the signature
    const signature = new Crypto().sign(
      new Crypto().hash(message),
      this.privateKey
    );

    // key increases after each signature
    this.counter += 1;

    return signature;
  }

  exportKey() {
    return this.publicKey;
  }

  exportCounter() {
    // this is hard to abuse, since one would need physcially push of a button
    // more than 2^256 times
    return this.counter;
  }

  exportAmount() {
    // TODO: this should be done properly on smart device
    return 5;
  }
}
